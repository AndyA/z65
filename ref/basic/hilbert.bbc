REM Hilbert Curve / Fat graphics
REM Turns out BBC Basic is UTF-8 safe
REM Andy Armstrong <andy@hexten.net>

oswrch      = &FFEE
osnewl      = &FFE7
zig_trace   = &FE90

scratch     = &50
tmp         = &70
row_a       = &74
row_b       = &76
buf         = &78
count       = &80
last_x      = &81
last_y      = &82

height      = 70
width       = 72

q_size%     = 9999 : REM Multiple of 3
q_in%       = 0
q_out%      = 0

DIM code 1000
DIM screen 8191

DIM queue q_size% - 1

FOR pass = 0 TO 2 STEP 2
P% = code
[OPT pass


.putwide    STA tmp
            ASL A
            ORA tmp
.putdot     STX tmp
            AND #&0F
            TAX
            BEQ putdot2
            LDA #&E2
            JSR oswrch
            LDA #&96
            JSR oswrch
            LDA dots, X
.putdot1    JSR oswrch
            LDX tmp
            RTS

.putdot2    LDA #ASC" "
            BNE putdot1

.dots       EQUB &20 : EQUB &98 : EQUB &9D : EQUB &80
            EQUB &96 : EQUB &8C : EQUB &9E : EQUB &9B
            EQUB &97 : EQUB &9A : EQUB &90 : EQUB &9C
            EQUB &84 : EQUB &99 : EQUB &9F : EQUB &88

.initscreen LDA #screen MOD 256
            STA row_a + 0
            CLC
            ADC #32
            STA row_b + 0
            LDA #screen DIV 256
            STA row_a + 1
            ADC #0
            STA row_b + 1
            LDA #height DIV 2
            STA count
            RTS

.nextrow    JSR osnewl
            LDX #row_a : JSR add64
            LDX #row_b : JSR add64
            DEC count
            RTS

.add64      CLC
            LDA 0, X
            ADC #64
            STA 0, X
            BCC add641
            INC 1, X
.add641     RTS

.showscreen JSR initscreen
.shows0     LDY #0
.shows1     LDA (row_a), Y \ top half of character
            LDX #3
.shows2     PHA
            AND #&03
            STA buf, X
            PLA
            LSR A : LSR A
            DEX
            BPL shows2
            LDA (row_b), Y \ bottom half of character
            LDX #3
.shows3     PHA
            ASL A : ASL A
            ORA buf, X
            JSR putdot
            PLA
            LSR A : LSR A
            DEX
            BPL shows3
            INY
            CPY #width DIV 8
            BCC shows1
            JSR nextrow
            BNE shows0
            RTS

.showwide   JSR initscreen
.showw0     LDY #0
.showw1     LDA (row_a), Y \ top half of character
            LDX #7
.showw2     PHA
            AND #&01
            STA buf, X
            PLA
            LSR A
            DEX
            BPL showw2
            LDA (row_b), Y \ bottom half of character
            LDX #7
.showw3     PHA
            AND #&01
            ASL A : ASL A
            ORA buf, X
            JSR putwide
            PLA
            LSR A
            DEX
            BPL showw3
            INY
            CPY #width DIV 8
            BCC showw1
            JSR nextrow
            BNE showw0
            RTS

.clear      LDY #screen MOD 256
            STY row_a + 0
            LDY #screen DIV 256
            STY row_a + 1
            LDY #0
            LDX #32
.cl1        STA (row_a), Y
            INY
            BNE cl1
            INC row_a + 1
            DEX
            BNE cl1
            RTS

.pixaddr    STX tmp + 0
            STY tmp + 1

            STX row_a + 0
            STY row_a + 1
            LDA #0
            TAX
            LSR row_a + 1 : ROR row_a + 0 : ROL A
            LSR row_a + 1 : ROR row_a + 0 : ROL A
            LSR row_a + 1 : ROR row_a + 0 : ROL A
            TAY
            LDA bits, Y
            PHA

            LDA row_a + 0
            ADC #screen MOD 256
            STA row_a + 0
            LDA row_a + 1
            ADC #screen DIV 256
            STA row_a + 1
            PLA
            RTS

.bits       EQUB &01 : EQUB &10 : EQUB &04 : EQUB &40
            EQUB &02 : EQUB &20 : EQUB &08 : EQUB &80

.getpix     JSR pixaddr
            AND (row_a, X)
            BEQ setpix5
            LDA #1
            BNE setpix5

.setpix     PHA
            CMP #0
            BNE setpix1
            JSR pixaddr
            EOR #&FF
            AND (row_a, X)
            BCC setpix3

.setpix1    CMP #1
            BNE setpix2
            JSR pixaddr
            ORA (row_a, X)
            BCC setpix3

.setpix2    CMP #2
            BNE setpix4
            JSR pixaddr
            EOR (row_a, X)
.setpix3    STA (row_a, X)
.setpix4    PLA
.setpix5    LDX tmp + 0
            LDY tmp + 1
            RTS

\ We're interested in four cases:
\  shallow +X +Y
\  shallow +X -Y
\  steep   +X +Y
\  steep   -X +Y

.draw       STA buf + 0
            TXA
            PHA
            SEC
            SBC last_x
            BCS draw1
            EOR #&FF
            ADC #1
.draw1      STA buf + 1 \ dX
            TYA
            PHA
            SEC
            SBC last_y
            BCS draw2
            EOR #&FF
            ADC #1
.draw2      STA buf + 2 \ dY
            PHA
            CLC
            ADC buf + 1
            ROR A
            STA count
            PLA
            CMP buf + 1
            BCS draw8 \ dY >= dX

\ Shallow

            CPX last_x
            BCC draw3
            JSR swapends
.draw3      INC last_x \ make end cond easier
            CPY last_y
            BCS draw6 \ Down

\ Shallow up

.draw4      LDA buf + 0
            JSR setpix
            LDA count
            SEC
            SBC buf + 2
            BCS draw5
            ADC buf + 1
            INY
.draw5      STA count
            INX
            CPX last_x
            BCC draw4
            BCS drawX

\ Shallow down

.draw6      LDA buf + 0
            JSR setpix
            LDA count
            SEC
            SBC buf + 2
            BCS draw7
            ADC buf + 1
            DEY
.draw7      STA count
            INX
            CPX last_x
            BCC draw6
            BCS drawX

\ Steep

.draw8      CPY last_y
            BCC draw9
            JSR swapends
.draw9      INC last_y
            CPX last_x
            BCS draw12 \ Left

\ Steep right

.draw10     LDA buf + 0
            JSR setpix
            LDA count
            SEC
            SBC buf + 1
            BCS draw11
            ADC buf + 2
            INX
.draw11     STA count
            INY
            CPY last_y
            BCC draw10
            BCS drawX

\ Steep left

.draw12     LDA buf + 0
            JSR setpix
            LDA count
            SEC
            SBC buf + 1
            BCS draw13
            ADC buf + 2
            DEX
.draw13     STA count
            INY
            CPY last_y
            BCC draw12

.drawX      PLA
            TAY
            PLA
            TAX
            LDA buf + 0

.move       STX last_x
            STY last_y
            RTS

.swapends   LDA last_x
            STX last_x
            TAX
            LDA last_y
            STY last_y
            TAY
            RTS

.debug_t    JSR trace
.debug      PHP
            PHA
            JSR prstr : EQUS "dX=" : EQUB 0
            LDA buf + 1 : JSR prdec
            JSR prstr : EQUS ", dY=" : EQUB 0
            LDA buf + 2 : JSR prdec
            JSR prstr : EQUS ", count=" : EQUB 0
            LDA count : JSR prdec
            JSR prstr : EQUS ", X=" : EQUB 0
            TXA : JSR prdec
            JSR prstr : EQUS ", Y=" : EQUB 0
            TYA : JSR prdec
            JSR prstr : EQUS ", lX=" : EQUB 0
            LDA last_x : JSR prdec
            JSR prstr : EQUS ", lY=" : EQUB 0
            LDA last_y : JSR prdec
            JSR osnewl
            PLA
            PLP
            RTS

.prstr      PLA
            STA scratch + 0
            PLA
            STA scratch + 1
            TYA
            PHA
            LDY #0
.prstr1     INC scratch + 0
            BNE prstr2
            INC scratch + 1
.prstr2     LDA (scratch), Y
            BEQ prstr3
            JSR oswrch
            JMP prstr1
.prstr3     PLA
            TAY
            LDA scratch + 1
            PHA
            LDA scratch + 0
            PHA
            RTS

.prdec      PHA
            STA scratch + 0
            TXA
            PHA
            LDA #0
            PHA
.prdec1     LDX #8
            LDA #0
.prdec2     ASL scratch + 0
            ROL A
            CMP #10
            BCC prdec3
            SBC #10
            INC scratch + 0
.prdec3     DEX
            BNE prdec2
            CLC
            ADC #ASC"0"
            PHA
            LDA scratch + 0
            BNE prdec1
.prdec4     PLA
            BEQ prdec5
            JSR oswrch
            JMP prdec4
.prdec5     PLA
            TAX
            PLA
            RTS

.trace      STA scratch + 0
            PHP : PLA : STA scratch + 1
            PLA : STA scratch + 2
            PLA : STA scratch + 3
            LDA zig_trace : PHA
            LDA #(trace_x - 1) DIV 256 : PHA
            LDA #(trace_x - 1) MOD 256 : PHA
            LDA scratch + 3 : PHA
            LDA scratch + 2 : PHA
            LDA #1 : STA zig_trace
            LDA scratch + 1 : PHA
            LDA scratch + 0
            PLP
            RTS

.trace_x    STA scratch + 0
            PHP : PLA : STA scratch + 1
            PLA : STA zig_trace
            LDA scratch + 1 : PHA
            LDA scratch + 0
            PLP
            RTS

]
NEXT
PRINT "Code size: "; P% - code

A% = 255 : CALL clear
init% = TRUE
PROChil(0, 0, 0, 0, 1, 1, 0, 5)

A% = 0 : X% =  4 : Y% = 0 : CALL move : Y% = 2 : CALL draw
A% = 0 : X% = 66 : Y% = 0 : CALL move : Y% = 2 : CALL draw

CALL showwide
REM PROCtest
END

DEF PROCline(A%, X%, Y%)
  IF init% THEN CALL move : init% = FALSE ELSE CALL draw
ENDPROC

DEF PROCseg(A%, x, y)
  PROCline(A%, 3 + x * 64, 2 + y * 64)
ENDPROC

DEF PROChil(A%, x, y, xi, xj, yi, yj, n)
  IF n <= 0 THEN PROCseg(A%, x + (xi + yi) / 2, y + (xj + yj) / 2) : ENDPROC
  PROChil(A%, x,           y,           yi/2, yj/2,  xi/2,  xj/2, n-1)
  PROChil(A%, x+xi/2,      y+xj/2 ,     xi/2, xj/2,  yi/2,  yj/2, n-1)
  PROChil(A%, x+xi/2+yi/2, y+xj/2+yj/2, xi/2, xj/2,  yi/2,  yj/2, n-1)
  PROChil(A%, x+xi/2+yi,   y+xj/2+yj,  -yi/2,-yj/2, -xi/2, -xj/2, n-1)
ENDPROC

DEF PROCpush(X%, Y%, G%)
  LOCAL next%
  next% = queue!q_in% AND &FF000000
  next% = next% OR ((G% AND 255) * 65536)
  next% = next% OR ((Y% AND 255) * 256)
  next% = next% OR (X% AND 255)
  queue!q_in% = next%
  q_in% = (q_in% + 3) MOD q_size%
  IF q_in% = q_out% THEN STOP
ENDPROC

DEF FNshift
  IF q_in% = q_out% THEN =FALSE
  LOCAL next%
  next% = queue!q_out%
  q_out% = (q_out% + 3) MOD q_size%
  X% = next% AND &FF
  Y% = (next% AND &FF00) DIV 256
  G% = (next% AND &FF0000) DIV 65536
=TRUE

DEF PROCtry(A%, X%, Y%, G%)
  IF (USR getpix AND &FF) <> A% THEN PROCpush(X%, Y%, G%)
ENDPROC

DEF PROCflood(A%, X%, Y%)
  LOCAL LG%, G%
  PROCtry(A%, X%, Y%, 0)
  IF NOT FNshift THEN ENDPROC
  REPEAT
    CALL setpix
    IF G% <> LG% THEN PRINT "Generation "; G% : CALL showwide : LG% = G%
    IF X% >   0 THEN PROCtry(A%, X% - 1, Y%,     G% + 1)
    IF X% < 255 THEN PROCtry(A%, X% + 1, Y%,     G% + 1)
    IF Y% >   0 THEN PROCtry(A%, X%,     Y% - 1, G% + 1)
    IF Y% < 255 THEN PROCtry(A%, X%,     Y% + 1, G% + 1)
  UNTIL NOT FNshift
  PRINT q_in%, q_out%
ENDPROC

DEF PROCtest
  LOCAL I%, X%, Y%, G%, x%, y%, g%
  FOR I% = 0 TO 4000
    X% = I% MOD 256          : x% = X%
    Y% = I% DIV 256          : y% = Y%
    G% = (I% DIV 16) MOD 256 : g% = G%
    PROCpush(X%, Y%, G%)
    PROCpush(X% EOR 255, Y% EOR 255, G% EOR 255)
    IF NOT FNshift THEN PROCfail : STOP
    IF X% <> x% OR Y% <> y% OR G% <> g% THEN PROCfail : STOP
    IF NOT FNshift THEN PROCfail : STOP
    IF X% <> (x% EOR 255) OR Y% <> (y% EOR 255) OR G% <> (g% EOR 255) THEN PROCfail : STOP
  NEXT
  IF FNshift THEN PROCfail : STOP
ENDPROC

DEF PROCfail
  PRINT "I="; I%
  PRINT "X="; X%; " x="; x%
  PRINT "Y="; Y%; " y="; y%
  PRINT "G="; G%; " g="; g%
ENDPROC